# 152. 乘积最大子数组

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

> 示例 1: 
>
> 输入: [2,3,-2,4]
>
> 输出: 6
>
>解释: 子数组 [2,3] 有最大乘积 6。

>示例 2:
>
> 输入: [-2,0,-1]
>
> 输出: 0
>
> 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。


## 题解
最简单的思路当然就是暴力求解啦，将每种可能的情况计算一遍，再取最大值，然而这当然是不可取的。本题可采用动态规划的思想。

假设 $f_{max}(i)$表示以$nums[i]$结尾的乘积最大的连续子数组对应的乘积。容易想到
$$f_{max}(i)= \max(f_{max}(i-1)*nums[i], nums[i])$$
然而这显然是不对的。举个例子：$nums = [2,3,-2,4,-3]$，按照上面的递推式可以得到$f_{max}(0) = 2$，$f_{max}(1) = 6$，$f_{max}(2) = 6$，$f_{max}(3) = 6$，$f_{max}(4) = 6$，而该数组对应的结果应该是数组中的所有数据相乘，即144。这是因为该数组中有两个负数，负负得正了。两个正数相乘，其值越大结果也越大，而两个负数相乘，其值越小结果越大。对于$nums = [2,3,-2,4,-3]$来说，由于$-3$是负数，那么给他乘一个很小的负数，就可以得到最大乘积。故我们可以考虑再维护一组变量$f_{min}(i)$，它表示以$nums[i]$结尾的乘积最大的连续子数组对应的乘积。最后得到的递推式为

$$f_{max}(i) = \max(f_{max}(i-1)*nums(i),f_{min}(i-1)*nums(i),nums(i))$$
$$f_{min}(i) = \min(f_{max}(i-1)*nums(i),f_{min}(i-1)*nums(i),nums(i))$$

最终的结果为$\max(f_{max}(i))$。时间复杂度和空间复杂度均为$O(n)$。

然而，$f_{max}(i)$,$f_{min}(i)$的中间结果其实不需要保存下来，直接用两个变量更新即可。如此可将空间复杂度降为$O(1)$

具体代码如下，注意$f_{max}$和$f_{min}(i)$是同时更新的，因此每次迭代时，应该设置一个中间变量将上一代的结果记录下来。

### Python版本

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        fmax = nums[0]
        fmin = nums[0]
        res = nums[0]
        for n in nums[1:]:
            mx, mn = fmax, fmin
            fmax = max(mx*n, mn*n, n)
            fmin = min(mx*n, mn*n, n)
            res = max(fmax,res)
        return res
```